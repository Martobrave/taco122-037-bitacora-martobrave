*** Al parecer, volví a no guardar lo escrito antes de irme, así que no tengo aquí documentado las fallas que tuve al tratar con dos pantallas OLED con los multiplexores azules, y que tampoco funcionó con 2 arduinos, uno R3 y otro R4, ahora colocaré lo que si me está funcionando: ***

# Trabajo Zoótropo espectador:

Código Arduino:

```

#include <SPI.h>
#include <Wire.h>
#include <Adafruit_GFX.h>
#include <Adafruit_SSD1306.h>

// Definiciones para Sensor Ultrasónico
#define TRIG_PIN 9
#define ECHO_PIN 10
#define MAX_DISTANCE_CM 200

// Definiciones para Motores (Driver 1)
#define ENA 6
#define IN1 7
#define IN2 8
#define ENB 5
#define IN3 11
#define IN4 12

// Definiciones para Motor 3 (Driver 2)
#define ENA2 3
#define IN1_2 2
#define IN2_2 4

// Definiciones para OLED
#define SCREEN_WIDTH 128
#define SCREEN_HEIGHT 64
#define OLED_RESET -1
Adafruit_SSD1306 display(SCREEN_WIDTH, SCREEN_HEIGHT, &Wire, OLED_RESET);
#define SCREEN_ADDRESS 0x3C

// Tu imagen
const unsigned char epd_bitmap_Screenshot_20251122_151423_TikTok_2__1_ [] PROGMEM = {
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc0, 0xff, 
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc0, 0xff, 0xff, 
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc0, 0xff, 0xff, 0xff, 
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc0, 0xff, 0xff, 0xff, 0xff, 
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc0, 0xff, 0xff, 0xff, 0xff, 0xff, 
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xbf, 
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0x3f, 0xff, 
    0xff, 0xff, 0xff, 0xff, 0xff, 0xc0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf8, 0x13, 0xff, 0xfe, 
    0x3f, 0xff, 0xff, 0xff, 0xc0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf9, 0xf8, 0x00, 0x1b, 0xc0, 0x1f, 
    0xff, 0xff, 0xff, 0xc0, 0xff, 0xff, 0xff, 0xff, 0xfe, 0x00, 0x70, 0x00, 0x03, 0x00, 0x0f, 0xff, 
    0xff, 0x7f, 0xc0, 0xff, 0xff, 0xff, 0xff, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0xff, 0xff, 
    0xbf, 0xc0, 0xff, 0xff, 0xff, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7f, 0xff, 0xff, 
    0xc0, 0xff, 0xff, 0xff, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfc, 0x00, 0x07, 0xff, 0xff, 0xc0, 
    0xff, 0xff, 0xff, 0xff, 0x00, 0x1e, 0x00, 0x00, 0x00, 0xff, 0xe0, 0x00, 0x7f, 0xff, 0xc0, 0xff, 
    0xff, 0xff, 0xff, 0x00, 0x1f, 0x00, 0x00, 0x00, 0xff, 0xf8, 0x00, 0x3f, 0xff, 0xc0, 0xff, 0xff, 
    0xff, 0xff, 0x00, 0x1f, 0xc0, 0x00, 0x00, 0xff, 0xfc, 0x00, 0x1f, 0xff, 0xc0, 0xff, 0xff, 0xff, 
    0xff, 0x00, 0x1f, 0xe6, 0x00, 0x00, 0x7f, 0xfe, 0x00, 0x03, 0xff, 0xc0, 0xff, 0xff, 0xff, 0xff, 
    0x08, 0x07, 0xf6, 0x00, 0x00, 0x7f, 0xff, 0x00, 0x01, 0xff, 0xc0, 0xff, 0xff, 0xff, 0xff, 0x0e, 
    0x01, 0xc0, 0x00, 0x20, 0x3f, 0xff, 0xc0, 0x00, 0xff, 0xc0, 0xff, 0xff, 0xff, 0xff, 0x06, 0x01, 
    0xc2, 0x00, 0x60, 0x1f, 0xff, 0xf8, 0x00, 0x3f, 0xc0, 0xff, 0xff, 0xff, 0xff, 0x80, 0x01, 0x8f, 
    0xc0, 0x00, 0x1f, 0xff, 0xff, 0x00, 0x07, 0xc0, 0xff, 0xff, 0xff, 0xff, 0x80, 0x03, 0xdf, 0xc0, 
    0x00, 0x0f, 0xff, 0xff, 0x80, 0x07, 0xc0, 0xff, 0xff, 0xff, 0xff, 0x80, 0x03, 0xff, 0xe0, 0x00, 
    0x1f, 0xff, 0xff, 0xe0, 0x03, 0xc0, 0xff, 0xff, 0xff, 0xff, 0x80, 0x07, 0xff, 0xe0, 0x00, 0x1f, 
    0xff, 0xff, 0xe0, 0x03, 0xc0, 0xff, 0xff, 0xff, 0xff, 0xc0, 0x07, 0xff, 0xf0, 0x00, 0x1f, 0xff, 
    0xff, 0xf0, 0x03, 0xc0, 0xff, 0xff, 0xff, 0xff, 0xc0, 0x07, 0xff, 0xf8, 0x02, 0x1f, 0xff, 0xff, 
    0xf0, 0x07, 0xc0, 0xff, 0xff, 0xff, 0xff, 0xe0, 0x07, 0xff, 0x7c, 0x04, 0x1f, 0xff, 0xff, 0xf8, 
    0x7f, 0xc0, 0xff, 0xff, 0xff, 0xff, 0xe0, 0x03, 0xff, 0x38, 0x00, 0x1f, 0xff, 0xff, 0xfc, 0x7f, 
    0xc0, 0xff, 0xff, 0xff, 0xff, 0xe0, 0x03, 0xff, 0x00, 0x00, 0x3f, 0xff, 0xff, 0xfe, 0xff, 0xc0, 
    0xff, 0xff, 0xff, 0xfe, 0x60, 0x01, 0xff, 0x00, 0x00, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xc0, 0xff, 
    0xff, 0xff, 0xfe, 0x00, 0x01, 0xff, 0x00, 0x00, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xc0, 0xff, 0xff, 
    0xff, 0xff, 0x00, 0x01, 0xff, 0x00, 0x00, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xc0, 0xff, 0xff, 0xff, 
    0xff, 0x00, 0x00, 0x7f, 0x00, 0x00, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xc0, 0xff, 0xff, 0xff, 0xff, 
    0x02, 0x00, 0x7e, 0x00, 0x00, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xc0, 0xff, 0xff, 0xff, 0xff, 0x84, 
    0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc0, 0xff, 0xff, 0xff, 0xff, 0x80, 0xc0, 
    0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc0, 0xff, 0xff, 0xff, 0xff, 0xc0, 0x40, 0x00, 
    0x00, 0x01, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc0, 0xff, 0xff, 0xff, 0xff, 0xc0, 0x40, 0x00, 0x00, 
    0x01, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc0, 0xff, 0xff, 0xff, 0xff, 0xe0, 0x00, 0x00, 0x00, 0x03, 
    0xff, 0xff, 0xff, 0xff, 0xff, 0xc0, 0xff, 0xff, 0xff, 0xff, 0xf0, 0x00, 0x00, 0x01, 0x07, 0xff, 
    0xff, 0xff, 0xff, 0xff, 0xc0, 0xff, 0xff, 0xff, 0xff, 0xf8, 0x00, 0x00, 0x00, 0x0f, 0xff, 0xff, 
    0xff, 0xff, 0xff, 0xc0, 0xff, 0xff, 0xff, 0xff, 0xfe, 0x00, 0x00, 0x00, 0x1f, 0xff, 0xff, 0xff, 
    0xff, 0xff, 0xc0, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x1f, 0xff, 0xff, 0xff, 0xff, 
    0xff, 0xc0, 0xff, 0xff, 0xff, 0xff, 0xff, 0x80, 0x00, 0x00, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 
    0xc0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc0, 0x40, 0x03, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc0, 
    0xff, 0xf7, 0xff, 0xff, 0xff, 0xfd, 0xef, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc0, 0xff, 
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc0, 0xff, 0xff, 
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc0, 0xff, 0xff, 
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc0, 0xff, 0xff, 
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc0, 0xff, 0xff, 
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc0, 0xff, 0xff, 
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc0, 0xff, 0xff, 
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc0, 0xff, 0xff, 
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc0, 0xff, 0xff, 
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc0, 0xff, 0xff, 
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc0, 0xff, 0xff, 
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc0, 0xff, 0xff, 
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc0, 0xff, 0xff, 
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc0, 0xff, 0xff, 
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc0, 0xff, 0xff
};


long duration;
int distance;
unsigned long previousMillis = 0;
const long interval = 100; // 100ms para lecturas más rápidas para Processing y OLED

void setup() {
  Serial.begin(9600); // Para comunicación con Processing
  pinMode(TRIG_PIN, OUTPUT);
  pinMode(ECHO_PIN, INPUT);
  pinMode(ENA, OUTPUT);
  pinMode(ENB, OUTPUT);
  pinMode(IN1, OUTPUT);
  pinMode(IN2, OUTPUT);
  pinMode(IN3, OUTPUT);
  pinMode(IN4, OUTPUT);
  pinMode(ENA2, OUTPUT);
  pinMode(IN1_2, OUTPUT);
  pinMode(IN2_2, OUTPUT);

  if(!display.begin(SSD1306_SWITCHCAPVCC, SCREEN_ADDRESS)) {
    Serial.println(F("OLED allocation failed"));
    for(;;);
  }
  display.clearDisplay();
}

void loop() {
  unsigned long currentMillis = millis();

  if (currentMillis - previousMillis >= interval) {
    previousMillis = currentMillis;

    // --- Lectura del sensor Ultrasónico ---
    digitalWrite(TRIG_PIN, LOW);
    delayMicroseconds(2);
    digitalWrite(TRIG_PIN, HIGH);
    delayMicroseconds(10);
    digitalWrite(TRIG_PIN, LOW);
    duration = pulseIn(ECHO_PIN, HIGH, 30000);
    distance = duration * 0.034 / 2;

    if (distance == 0 || distance > MAX_DISTANCE_CM) distance = MAX_DISTANCE_CM;

    // --- ENVIAR DISTANCIA A PROCESSING (AUNQUE TAMBIEN SE USA PARA OLED) ---
    Serial.println(distance);

    // --- Lógica de velocidad de motores ---
    int speedMotor = map(distance, 0, 100, 255, 0);
    speedMotor = constrain(speedMotor, 0, 255);

    // --- Control de Motores ---
    analogWrite(ENA, speedMotor);
    analogWrite(ENB, speedMotor);
    analogWrite(ENA2, speedMotor);
    digitalWrite(IN1, HIGH);
    digitalWrite(IN2, LOW);
    digitalWrite(IN3, HIGH);
    digitalWrite(IN4, LOW);
    digitalWrite(IN1_2, HIGH);
    digitalWrite(IN2_2, LOW);

    // --- Control de Pantalla OLED CONDICIONAL ---
    display.clearDisplay(); // Limpia la pantalla en cada ciclo

    if (distance <= 50) {
      // SOLO dibuja la imagen si la distancia es 50cm o menor
      display.drawBitmap(14, 0, epd_bitmap_Screenshot_20251122_151423_TikTok_2__1_, 114, 64, SSD1306_WHITE); 
    }
    
    display.display(); // Envía el buffer a la pantalla física
  }
}


```

Código Processing:

```
import processing.serial.*;
import processing.video.*;

Serial myPort;        // El objeto puerto serial
Capture cam;         // El objeto de captura de video
int dist = 0;        // Variable para almacenar la distancia recibida

// Variables para controlar la pixelización
int minPixelSize = 1;  // Tamaño de píxel mínimo (alta resolución)
int maxPixelSize = 40; // Tamaño de píxel máximo (muy pixelado)
int pixelSize = 1;     // Tamaño de píxel actual

void setup() {
  size(640, 480); 
  
  // Imprime los puertos seriales disponibles en la consola de Processing
  println(Serial.list());
  
  // *** LÍNEA CORREGIDA ***
  // Selecciona el primer puerto de la lista usando [0]
  String portName = Serial.list()[0]; 
  myPort = new Serial(this, portName, 9600);

  // Inicializa la cámara
  cam = new Capture(this, 640, 480);
  cam.start();
}

void draw() {
  if (cam.available()) {
    cam.read(); // Lee el nuevo frame de la cámara
  }
  
  // Aseguramos que el fondo se limpie en cada frame
  background(0);

  // --- Aplica el efecto de espejo (volteo horizontal) ---
  
  pushMatrix();          // Guarda la configuración de dibujo actual
  translate(cam.width, 0); // Mueve el origen al lado derecho de la imagen (X=640)
  scale(-1, 1);          // Invierte la escala horizontalmente (crea el espejo)
  
  // Aplica el efecto de pixelización dinámico.
  // Como estamos volteados, dibujamos en la posición X=0
  applyPixelEffect(0); 
  
  popMatrix();           // Restaura la configuración original

  // Muestra la distancia en pantalla (opcional)
  fill(255);
  textSize(24);
  text("Distancia: " + dist + " cm", 10, 30);
}

void serialEvent(Serial myPort) {
  String inString = myPort.readStringUntil('\n');

  if (inString != null) {
    inString = trim(inString);
    dist = int(inString);
    
    // Mapeo para el efecto pixelado
    pixelSize = (int)map(dist, 0, 200, minPixelSize, maxPixelSize);
    if (pixelSize < 1) pixelSize = 1;
  }
}

// Función para aplicar el efecto pixelado
void applyPixelEffect(int startX) {
  if (pixelSize == 1) {
    image(cam, startX, 0);
    return;
  }
  
  int step = pixelSize;
  for (int y = 0; y < cam.height; y += step) {
    for (int x = 0; x < cam.width; x += step) {
      color c = cam.get(x, y); 
      noStroke();
      fill(c);
      rect(startX + x, y, step, step);
    }
  }
}

```

